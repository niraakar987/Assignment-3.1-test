# Assignment-3.1-test

The project requisition system that has been implemented using Python and is a request for supplies to be forwarded by employees and for managers to view and respond to them. Since the system itself works as intended, understanding the code from the point of view of principles of software design enabled me to understand better why a program, apart from working, is also robust and versatile. In this context, I’ve focused on identifying where these principles were applied, where they were unintentionally missed, and how they could be improved moving forward.
One issue that stood out early on was the use of a global variable called counter to generate requisition IDs. At first, this seemed like a simple way to keep track of IDs. However, I’ve since learned that using global state like this can lead to complications as the program becomes larger. Since global variables can be accessed and modified from anywhere, they can create undesired side effects. A better approach would be to encapsulate this counter inside the class — either as a class variable or as an instance variable. This would keep it protected and better reflect object-oriented design.
Looking deeper into the structure of the methods, I noticed some violations of the Single Responsibility Principle (SRP). For example, the staff_info() method does two things: it collects user input and generates a new requisition ID. Ideally, these should be handled separately so that each function has one clear purpose. The same applies to the create_requisition() method, which currently handles data collection, total calculation, approval status, and storage — all within one block. Breaking these into smaller, focused methods would not only make the code easier to read but also simplify future updates or testing.
The DRY (Don’t Repeat Yourself) principle is commonly used, but there's still something to improve One example is the logic for generating approval references. It appears more than once and uses the same formatting. Instead of repeating that logic, it would be cleaner to move it into a helper method that can be reused whenever needed. This small change would make the code more adaptable if the format ever needs to be changed.
With this into bargin, I tried to follow the KISS (Keep It Simple, Stupid) principle. Most of the logic uses clear, straightforward structures like loops and conditionals. The menu system is easy to navigate, and the user prompts are direct. However, the main() method does a bit too much — from displaying the menu to handling input and executing actions. It would be more maintainable to split these tasks into separate functions. That way, if I ever needed to change how the menu works, I wouldn't have to dig through all the other logic at the same time.
The project has helped me to understand the difference between code that just works and code that is well-designed. These design principles aren't just theoretical — they really do make programs easier to understand, maintain, and scale. If I have to return to this system in the future, I'd focus on better separation of concerns, elimination of duplicated logic, and preservation of privacy of data where it's needed. This task reminded me that good code isn't written, it's engineered.

